% ifONLY (draft specification)
% Jon Craton

> We were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp. 
> 
> - Guy Steele, co-author of the Java spec [5] 

>  Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified bug-ridden slow implementation of half of Common Lisp.
>
> - Philip Greenspun [4]

> Programming should be regarded as the art of telling another human being what one wants the computer to do.
>
> - Don Knuth [6]

> I thought that it was a firm principle of language design --out of concern for programming as a human activity-- that in all respects equivalent programs should have few possibilities for different representations (possibility for differences ideally not going beyond the arbitrary choice of identifiers and the arbitrary ordering of syntactically unordered components). Otherwise completely different styles of programming arise unnecessarily, thereby hampering maintainability, readability and what have you. This requires from the language designers the courage to make up their minds!
>
> - Edsger Dijkstra [7][8]

Guiding Principles
==================

1. Correct code should look correct. Incorrect code should look incorrect.
  - White space is significant
  - Side effects should be loud and obvious
2. There should be exactly one correct way to perform a simple task.
  - The language has an embedded code formatter to bring code up to spec with very specific and required style guidelines.
3. Inline testing and documentation is a core construct.
  - Built in unit testing at the function level. Compiler warnings available and enabled by default when unit tests are missing. All unit tests are completed at compile time and a failed test is a failed build.
4. Where existing mathematical notation exists, it should be used in place of inventing to notation.
  - If an existing unicode character exists for some operation, it should be used in favor of traditional ASCII replacements.
5. Boilerplate and extraneous syntax should be kept to an absolute miniumum.
  - Significant whitespace
  - Many aspects of the syntax are optional and should only be included when required.

Types
=====

Literals
--------

----

The following literals are provides:

- Grapheme - A single Unicode grapheme
  - e.g. 'a' or '→'
- Number - A scalable number supporting unlimited integer precision and precision no worse than an IEEE 64-bit float for floating point operations.
  - e.g. 1.0 or 1 or 1e300

Functions
---------

----

Functions should be seen as the core construct of the language. There is exactly one way to define a function. Note that the following is an expression, and not a statment. It returns a function:

```
params →
  function body
```

To assign a function to a variable, one would do the following:

```
my_fn = params →
  function body
```

Functions may be bound to other objects. When they are called in this way, the first parameter of the function is the object that they are bound to.

```
my_obj.func = self →
  function body with self mapped to my_obj

my_obj.func()
```

Lists
-----

The following expression returns a list of strings:

```
<indent>
"item1"
"item2"
```

This can be bound to a variable as:

```
my_list = 
  "item1"
  "item2"
```

Tuples
------

Tuples are a data type of fixed size composed of other datatypes. The following would be a tuple of length 3:

```
1,"two",3
```

Objects
-------

Note that objects are simply lists whose members are key/value tuples. When a list is made up of tuples where the first item is hashable, the list is considered to be an object. The following expression returns an "object":

```
<indent>
item1, 1
item2, 2
```

This expression may be bound to a varibale as:

```
my_obj = 
  item1, 1
  item2, 2
```

Strings
-------

Special syntax is provides for creating lists of graphemes:

```
"A string"
```

Is precisely the same as:

```
<indent>
'A'
' '
'S'
't'
'r'
'i'
'n'
'g'
```

String notation should always be preferred to list of grapheme.

Names, Scope, and Binding
=========================

Names
-----

----

Names may include any non-whitespace characters and must not start with a number. They may not include operators in their names.

There are no variable declarations. Variables are inferred to be local if they are assigned in a function.

Scope
-----

----

The language uses function scope. Function local variable scope is handled lexically, so nested functions have access to their parent's scope, but other called functions do not.[10]

Binding
-------

Binding is done by the following:

```
my_var = 1
```

Binding may also be accomplished using match syntax:

```
_ my_fun _ = (left, right) -> 
  function body
```

This can be used to define new infix functions such as operators:

```
```

----

The language uses

Control Flow
============

if-then-else
------------

The language provides a fairly standard if-then-else expression as:

```
result = if True
  10
else
  20

#result is 10
```

for
---

---

For loops are provides very simply as:

```
for i in list
  do something
```

If the variable name is left out, one will be automatically selected to not collide with other names starting from i. For example, the following is valid:

```
for list_a
  for list_b
    print(i, j)
```

Comparison
----------

----

Comparison - Comparison is always done by value.

Operators
---------

----

Mathematical syntax is used whenever possible for operators for example:

- and is ∧
- or is ∨
- not is ¬

Features
========

Derived Ranges
--------------

----

Consider iterating over the even integers between 1 and 100 in JavaScript:

    for(i=2; i<=100; i+=2) {
      \\ Do something with i
    }

Or doing the same thing in Python:

    for i in range(2,100,2):
      \\ Do something with i

While a programmer gets very used to writing and reading these sorts of expressions, they are very far from how we would naturally express ideas to one another.

We might like to be able to do something like this:

    for i in [2,4,6,...,100]:
      \\ Do something with i

It's natural for us to grasp ideas by example, and a computer should be able to construct programs in the same way. These sorts of derived ranges are one practical example of how that can happen.

Derived Operations
------------------

The language defines no operations. They are all derived by example.

For example, a compiler would discover division from the following example:

```
derive a / b matching:
  1 / 1 is 1
  2 / 2 is 1
  2 / 1 is 2
  6 / 2 is 3  
```

Or concatenation:

```
derive a + b matching:
  abc + def is abcdef
```

Functions
---------

Function may be infix, prefix, or postfix depending on how they are defined. Here's a prefix definition:

```
func pow a b:
  val = 1

  for [0...b]:
    val *= a

  return val
```

Here's the same definition for an infix `^` operator:

```
func a ^ b
  val = 1

  for [0...b]
    val *= a

  return val
```

Functions don't simply have names, but instead have a complete signature. For example, you can define a C++ ternary operator as:

``` 
func expr ? v_true : v_false
  if expr
    v_true
  else:
    v_false
```

Data types
----------

### Literals

A litteral is a string of utf8 characters. The compiler may use this as an integer, float, string, etc depending on how it is used.

Everything is an expression
---------------------------

    result = if True:
      1
    else:
      2

`result` evaluates to 1.

  - There is not a traditional imperative looping construct. Consider the following example:

```
squares = for i in [0,1,…,4]:
  i*i

print(squares)
```

This prints "[0,1,4,9,16]". However, it does not evaluate anything until squares needs to be printed. The following code executes exactly 1 multiply operation, because squares is evaluated lazily:

```
squares = for i in [0,1,…,4]:
  i*i

print(squares[0])
```

- 7 - Type Systems
  - The language supports *optional* static typing. That is, it has the ability to be dynamically typed, but static types may be declared and checked at compile time where they are desired. This is known as gradual typing[3].
- 8 - Composite Types
  - Every type is composed of a primary and a number of secondary types. Secondary types may be accessed in order using number and may also be access by name.

Consider the basic integer. It's primary value is some number, and it's secondary value is nil.

Other types have a primary type such as `list` and a secondary type containing it's items.

OOP
===

This language does not seek to provide syntactic sugar for object oriented programming. Object oriented programs can be crafted by explictly passing data structures to functions meant to operate on these structures.

Types
=====
This language is strongly and statically typed. All types are automatically inferred. This would likely be implemented using a system such as Hindley-Milner[1].

Literals
--------

Single values may be part of one or more of the following types:

- `boolean` (x∈{0,1})
- `real` (x∈ℝ|x=1) - e.g. 3.14159… - Any real number. This captures infinite precision.
  - `rational` (x∈ℚ) - e.g. 0.33…
  - `integer` (x∈ℤ) - e.g. -17 - Integers may be used anywhere numbers are expected. The reverse is not true. Some operations may require integer parameters, such as list indices.
    - `natural` (x∈ℕ) e.g. 4 Some operations may require `natural` parameters, such as list indices. Natural numbers include 0 for this purpose.
- `grapheme` - e.g. q - The smallest unit of a written language. This should absolutely not be confused with a byte, word, character, or any other implementation detail.

The language has no support for the following:

- Direct bit manipulation
- Strings

Lists
-----

Lists are one of the two core building blocks of the type system. A list contains a number of values (possibly infinite values), each having the same type. Lists are constructed without any special delimiters as follows:

    abcd
    1.0 2.0 3.0
    1 2 3

The following are not valid lists:

    1 abcd

Tuples
------

A tuple is an ordered grouping of values. Values can be of any type, and the length of a tuple may be infinite.

Tuples are always defined using set builder notation in final code[2]: `⟨x∈ℕ|x≤3⟩` produces `⟨1,2,3⟩`

Tuples may also be defined using the following in draft code:

- Roster notation: `⟨1,2,3⟩`
- Ellipsis notation: `⟨1,2,3,…⟩` Note the use of a unicode ellipsis. Three periods are not an ellipsis…

Roster and ellipsis notation are both permanently converted to set builder notation by the formatting pass.

The exception to this rule is that finite grapheme tuples must be built as `"abcd"`. Roster notation will be automatically converted to this syntax by the formatter.

Sets
----

Sets are simply tuples without order or duplicate values. The syntax is the same as tuples with angle brackets replaced by set brackets ({}).

Stream
------

A stream is mutable.

Examples
========

Count to 10
-----------

    λ
      ⟨x∈ℕ|x≤10⟩

Hello, {name}!
--------------

    λ in∈⟨x∈G⟩ =
      "Hello, " ∪ in ∪ "!"

Factorial
--------------

    λ in∈⟨x∈G⟩ =
      "Hello, " ∪ in ∪ "!"

Control Flow
============

This doesn't exist as it is typically conceptualized in imperative languages. There are several provided expression to handle cases of control flow that may be desired.



Scope
=====

Builtins
========

Selection (filter) - σexpr(list)
Summation (reduce) - ∑(over,list)

π (pi = 3.14159…)
¬ (logical negation)

Mutability
==========

All variables are immutable once declared.

Whitespace
==========

There are two valid whitespace characters. These are space, as in 0x20, and line breaks, as in 0x12. Using tabs (0x11) or carriage returns (0x15) as whitespace characters is illegal.

References
==========

1. https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
2. https://en.wikipedia.org/wiki/Set-builder_notation
3. https://en.wikipedia.org/wiki/Gradual_typing
4. http://philip.greenspun.com/research/
5. http://www.paulgraham.com/icad.html
6. {The textbook}
7. http://www.cs.utexas.edu/~EWD/transcriptions/EWD06xx/EWD660.html
8. https://softwareengineering.stackexchange.com/questions/148790/is-the-14th-line-of-the-zen-of-python-a-reference-to-dijkstra#148794
9. https://en.wikipedia.org/wiki/Anonymous_function
10. https://en.wikipedia.org/wiki/Scope_(computer_science)#Function_scope