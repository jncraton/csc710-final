% ifONLY (draft specification)
% Jon Craton

> We were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp. 
> 
> - Guy Steele, co-author of the Java spec [5] 

>  Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified bug-ridden slow implementation of half of Common Lisp.
>
> - Philip Greenspun [4]

> Programming should be regarded as the art of telling another human being what one wants the computer to do.
>
> - Don Knuth [6]

> I thought that it was a firm principle of language design --out of concern for programming as a human activity-- that in all respects equivalent programs should have few possibilities for different representations (possibility for differences ideally not going beyond the arbitrary choice of identifiers and the arbitrary ordering of syntactically unordered components). Otherwise completely different styles of programming arise unnecessarily, thereby hampering maintainability, readability and what have you. This requires from the language designers the courage to make up their minds!
>
> - Edsger Dijkstra [7][8]

Guiding Principles
==================

1. Correct code should look correct. Incorrect code should look incorrect.
  - White space is significant
  - Side effects should be loud and obvious
2. There should be exactly one correct way to perform a simple task.
  - The language has an embedded code formatter to bring code up to spec with very specific and required style guidelines.
3. Inline testing and documentation is a core construct.
  - Built in unit testing at the function level. Compiler warnings available and enabled by default when unit tests are missing. All unit tests are completed at compile time and a failed test is a failed build.
4. Where existing mathematical notation exists, it should be used in place of inventing to notation.
  - If an existing unicode character exists for some operation, it should be used in favor of traditional ASCII replacements.
5. Boilerplate and extraneous syntax should be kept to an absolute miniumum.
  - Significant whitespace
  - Many aspects of the syntax are optional and should only be included when required.

Types
=====

Literals
--------

----

The following literals are provides:

- Grapheme - A single Unicode grapheme
  - e.g. 'a' or '→'
- Number - A scalable number supporting unlimited integer precision and precision no worse than an IEEE 64-bit float for floating point operations.
  - e.g. 1.0 or 1 or 1e300

Functions
---------

----

Functions should be seen as the core construct of the language. There is exactly one way to define a function. Note that the following is an expression, and not a statment. It returns a function:

```
params →
  function body
```

To assign a function to a variable, one would do the following:

```
my_fn = params →
  function body
```

Functions may be bound to other objects. When they are called in this way, the first parameter of the function is the object that they are bound to.

```
my_obj.func = self →
  function body with self mapped to my_obj

my_obj.func()
```

Lists
-----

The following expression returns a list of strings:

```
<indent>
"item1"
"item2"
```

This can be bound to a variable as:

```
my_list = 
  "item1"
  "item2"
```

Tuples
------

Tuples are a data type of fixed size composed of other datatypes. The following would be a tuple of length 3:

```
1,"two",3
```

Objects
-------

Note that objects are simply lists whose members are key/value tuples. When a list is made up of tuples where the first item is hashable, the list is considered to be an object. The following expression returns an "object":

```
<indent>
item1, 1
item2, 2
```

This expression may be bound to a varibale as:

```
my_obj = 
  item1, 1
  item2, 2
```

Strings
-------

Special syntax is provides for creating lists of graphemes:

```
"A string"
```

Is precisely the same as:

```
<indent>
'A'
' '
'S'
't'
'r'
'i'
'n'
'g'
```

String notation should always be preferred to list of grapheme.

Names, Scope, and Binding
=========================

Names
-----

----

Names may include any non-whitespace characters and must not start with a number. They may not include operators in their names. This is a standard choice present in most languages.

There are no variable declarations. Variables are inferred to be local if they are assigned in a function. This prevents boilerplate declarations and generally requires fewer lines of code to perform a task. This is the same method used in Python.

Scope
-----

----

The language uses function scope. Function local variable scope is handled lexically, so nested functions have access to their parent's scope, but other called functions do not.[10]

This choice allows functions to be the core unit of the language. There are no blocks outside of functions. Functions are the unit of scope.

Binding
-------

Binding is done by the following:

```
my_var = 1
```

Binding may also be accomplished using match syntax:

```
_ my_fun _ = (left, right) -> 
  function body
```

This can be used to define new infix functions such as operators:

```
```

----

The language uses deep binding. I find this to be easier to read and reason about.

Control Flow
============

if-then-else
------------

The language provides a fairly standard if-then-else expression as:

```
result = if True
  10
else
  20

#result is 10
```

for
---

---

For loops are provided very simply as:

```
for i in list
  do something
```

If the variable name is left out, one will be automatically selected to not collide with other names starting from i. For example, the following is valid:

```
for list_a
  for list_b
    print(i, j)
```

Comparison
----------

----

Comparison - Comparison is always done by value.

Operators
---------

----

Mathematical syntax is used whenever possible for operators for example:

- and is ∧
- or is ∨
- not is ¬
- less than or equal is ≤
- greater than or equal is ≥

Features
========

Derived Ranges
--------------

----

Consider iterating over the even integers between 1 and 100 in JavaScript:

    for(i=2; i<=100; i+=2) {
      \\ Do something with i
    }

Or doing the same thing in Python:

    for i in range(2,100,2):
      \\ Do something with i

While a programmer gets very used to writing and reading these sorts of expressions, they are very far from how we would naturally express ideas to one another.

We might like to be able to do something like this:

    for i in [2,4,6,...,100]:
      \\ Do something with i

It's natural for us to grasp ideas by example, and a computer should be able to construct programs in the same way. These sorts of derived ranges are one practical example of how that can happen.

Derived Operations
------------------

The language defines no operations. They are all derived by example.

For example, a compiler would discover division from the following example:

```
derive a / b matching:
  1 / 1 is 1
  2 / 2 is 1
  2 / 1 is 2
  6 / 2 is 3  
```

Or concatenation:

```
derive a + b matching:
  abc + def is abcdef
```

Functions
---------

Function may be infix, prefix, or postfix depending on how they are defined. Here's a prefix definition:

```
func pow a b:
  val = 1

  for [0...b]:
    val *= a

  return val
```

Here's the same definition for an infix `^` operator:

```
func a ^ b
  val = 1

  for [0...b]
    val *= a

  return val
```

Functions don't simply have names, but instead have a complete signature. For example, you can define a C++ ternary operator as:

``` 
func expr ? v_true : v_false
  if expr
    v_true
  else:
    v_false
```

- 7 - Type Systems
  - The language supports *optional* static typing. That is, it has the ability to be dynamically typed, but static types may be declared and checked at compile time where they are desired. This is known as gradual typing[3].
- 8 - Composite Types
  - Every type is composed of a primary and a number of secondary types. Secondary types may be accessed in order using number and may also be access by name.

Consider the basic integer. It's primary value is some number, and it's secondary value is nil.

Other types have a primary type such as `list` and a secondary type containing it's items.

OOP
===

This language does not seek to provide syntactic sugar for object oriented programming. Object oriented programs can be crafted by explictly passing data structures to functions meant to operate on these structures.

Types
=====
This language is strongly and statically typed. All types are automatically inferred. This would likely be implemented using a system such as Hindley-Milner[1].

Builtins
========

Selection (filter) - σexpr(list)
Summation (reduce) - ∑(over,list)

π (pi = 3.14159…)
¬ (logical negation)

Mutability
==========

All variables are immutable once declared.

Whitespace
==========

There are two valid whitespace characters. These are space, as in 0x20, and line breaks, as in 0x12. Using tabs (0x11) or carriage returns (0x15) as whitespace characters is illegal.

References
==========

1. https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
2. https://en.wikipedia.org/wiki/Set-builder_notation
3. https://en.wikipedia.org/wiki/Gradual_typing
4. http://philip.greenspun.com/research/
5. http://www.paulgraham.com/icad.html
6. {The textbook}
7. http://www.cs.utexas.edu/~EWD/transcriptions/EWD06xx/EWD660.html
8. https://softwareengineering.stackexchange.com/questions/148790/is-the-14th-line-of-the-zen-of-python-a-reference-to-dijkstra#148794
9. https://en.wikipedia.org/wiki/Anonymous_function
10. https://en.wikipedia.org/wiki/Scope_(computer_science)#Function_scope