% Programming Language Draft Specification
% Jon Craton

> Programming should be regarded as the art of telling another human being what one wants the computer to do.
>
> - Don Knuth [6]

Guiding Principles
==================

> Simplicity and straighforwardness proceed from conceptual integrity. Every part must reflect the same philosophies and the same balancing of desiderata. Every part must even use the same techniques in syntax and analogous notions in semantics. Ease of use, then, dictates unity of design, conceptual integrity. 
> Fredrick Brooks[14]

Exactly One Correct Way
-----------------------

> I thought that it was a firm principle of language design — out of concern for programming as a human activity — that in all respects equivalent programs should have few possibilities for different representations (possibility for differences ideally not going beyond the arbitrary choice of identifiers and the arbitrary ordering of syntactically unordered components). Otherwise completely different styles of programming arise unnecessarily, thereby hampering maintainability, readability and what have you. This requires from the language designers the courage to make up their minds!
>
> - Edsger Dijkstra [7][8]

To ensure simplicity and readability, my first guiding principle is that the language should provide exactly one obviously correct way to perform a task. This will almost certainly make the language uncomfortable to actually use, but I thought it might be a fun excercise given that no one will actually be using this language anyhow.

The language is opinionated about *how* it is written. The language has an embedded code formatter to bring code up to spec with very specific and required style guidelines.

Correct Code Should Look Correct
--------------------------------

> Programs must be written for people to read, and only incidentally for machines to execute.
> 
> - H. Abelson and G. Sussman[11]

In order to reduce errors and improve readability, every effort was made to ensure that code that does something looks like it is doing that. Consider this classic example from C-like language. Here we have a for loop:

    int i;

    for (int i = 0; i<=10; i++)
      i = i*i
      print(i)
      
At first glance, this may look like it will print out the squares of numbers from 1 to 10. It will actually just print 100. The above in functionally the same as this:

    int i;

    for (int i = 0; i<=10; i++)
      i = i*i

    print(i)

It should be written as:

    int i;

    for (int i = 0; i<=10; i++) {
      i = i*i
      print(i)
    }

These sort of shenanigans would ideally not be part of a sound programming language. In order to eliminate these errors, white space is considered to be a significant and important part of the language syntax.

> A common mistake people make when trying to design something completely foolproof is to underestimate the ingenuity of complete fools.
> 
> - Douglas Adams[13]

First-class Testing
-------------------

> Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.
> 
> - Edsger Dijkstra[15][16]

In order to enhance correctness and readability of functions, unit testing will be a first-class member of the language. In order to compile without warnings, all functions must specify test for deliniating their intended behaviour.

Compiler warnings are available and enabled by default when unit tests are missing. All unit tests are completed at compile time and a failed test is a failed build.

Prioritize Existing Notation
----------------------------

> That language is an instrument of human reason, and not merely a medium for the expression of thought, is a truth generally admitted.
> - George Boole[12]

Where existing mathematical notation exists, it should be used in place of inventing notation or using notation from other programming languages.

Unicode is required and used in key parts of the language. If an existing unicode character exists for some operation, it should be used in favor of traditional ASCII replacements.

Details optional
----------------

Boilerplate and extraneous syntax should be kept to an absolute miniumum. Many aspects of the syntax are optional and should only be used when required to address ambiguities.

Types
=====

Literals
--------

----

The following literals are provided:

- Grapheme - A single Unicode grapheme
  - e.g. 'a' or '→'
- Number - A scalable number supporting unlimited integer precision and precision no worse than an IEEE 64-bit float for floating point operations.
  - e.g. 1.0 or 1 or 1e300

Functions
---------

----

Functions should be seen as the core construct of the language. There is exactly one way to define a function. Note that the following is an expression, and not a statment. It returns a function:

    params →
      function body

To assign a function to a variable, one would do the following:

    my_fn ≡ params →
      function body

Functions may be bound to other objects. When they are called in this way, the first parameter of the function is the object that they are bound to.

    my_obj.func ≡ self →
      function body with self mapped to my_obj
    
    my_obj.func()

Lists
-----

>  Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified bug-ridden slow implementation of half of Common Lisp.
>
> - Philip Greenspun [4]

Lists are ordered groups of items of the same time. They do not have a fixed length.

The following expression returns a list of strings:

    <indent>
    "item1"
    "item2"
    …

This can be bound to a variable as:

my_list = 
  "item1"
  "item2"
  …

Tuples
------

Tuples are a data type of fixed size composed of other datatypes. The following would be a tuple of length 3:

    <indent>
    1 "two" 3

Tuples may optionally be defined over multiple lines as:

    <indent>
    1
    "two"
    3

Tuple construction is differentiated from list construction by the lack of ellipses.

Objects
-------

Note that objects are simply lists whose members are key/value tuples. When a list is made up of tuples where the first item is hashable, the list is considered to be an object. The following expression returns an "object":

    <indent>
    item1 1
    item2 2

This expression may be bound to a varibale as:

    my_obj ≡ 
      item1 1
      item2 2

Strings
-------

Special syntax is provided for creating lists of graphemes:

    "A string"

Is precisely the same as:

    <indent>
    'A'
    ' '
    'S'
    't'
    'r'
    'i'
    'n'
    'g'

String notation should always be preferred to list of grapheme.

Vectors
-------

A vector can be thought of either as a fixed lenght list or a tuple whose elements all have the same type. It is constructed exactly as a tuple and identified using duck typing. Here's an example vector:

    <indent>
    1
    2
    3

Matrices
--------

An N×M matrix is simply an N-tuple of M-tuples. Here is an example identity matrix:

    <indent>
    1 0 0 0
    0 1 0 0
    0 0 1 0
    0 0 0 1

Names, Scope, and Binding
=========================

Names
-----

----

Names may include any non-whitespace characters and must not start with a number. They may not include operators in their names. This is a standard choice present in most languages.

There are no variable declarations. Variables are inferred to be local if they are assigned in a function. This prevents boilerplate declarations and generally requires fewer lines of code to perform a task. This is the same method used in Python.

Scope
-----

----

The language uses function scope. Function local variable scope is handled lexically, so nested functions have access to their parent's scope, but other called functions do not.[10]

This choice allows functions to be the core unit of the language. There are no blocks outside of functions. Functions are the unit of scope.

Binding
-------

Binding is done by the following:

    my_var ≡ 1

Binding is the only statement in the language. It literally maps one expression to another such that they can now be used interchangably.

Binding may also be accomplished using match syntax:

    _ my_fun _ ≡ left right → 
      function body

This can be used to define new infix functions such as operators:

    _ · _ ≡ a b →
      a × b

----

The language uses deep binding. I find this to be easier to read and reason about.

Control Flow
============

> We were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp. 
> 
> - Guy Steele, co-author of the Java spec [5] 

Matching
--------

The language provides a fairly standard if-then-else expression as:

    result ≡ if x
      10
    else
      20

Because brackets are freed up from their traditional ALGOL usage for blocks, they can be repurposed to their more standard mathematical notation i.e.:

$f(x) = \left\{
   \begin{array}{rl}
     a, & \text{if } p(x) \\
     b, & \text{if } q(x)
   \end{array}\right.$

Here's how match syntax for the above `if` expression looks:

    result ≡ 
      { 10 if x
      { 20

Loops
-----

---

For loops are provided very simply as:

    for list i →
      function body

Notice that for loop bodies are actually functions, so you can easily call a function for every item in a list. In addition, for is an expression, not a statement. It returns a list of the results to all of the function calls. We can implement map as:

    square ≡ x →
      x²
    
    squares ≡ for [1…9] square
    # squares is [1,4,9,16,25,…]

Or without binding the function to a name:

    squares ≡ for [1…9] x →
      x²

Summation
---------

----

Summation is also provided in nearly the same way as `for`:

    sum_of_squares ≡ Σ [1…9] x →
      x²

Comparison
----------

----

Comparison - Comparison is always done by value.

Operators
---------

----

Mathematical syntax is used whenever possible for operators for example:

- and is ∧
- or is ∨
- not is ¬
- less than or equal is ≤
- greater than or equal is ≥
- equivalence is =
- binding is ≡

Features
========

Derived Ranges
--------------

----

Consider iterating over the even integers between 1 and 100 in JavaScript:

    for(i=2; i<=100; i+=2) {
      \\ Do something with i
    }

Or doing the same thing in Python:

    for i in range(2,100,2):
      \\ Do something with i

While a programmer gets very used to writing and reading these sorts of expressions, they are very far from how we would naturally express ideas to one another.

We might like to be able to do something like this:

    for [2,4,6,...,100] i →
      \\ Do something with i

It's natural for us to grasp ideas by example, and a computer should be able to construct programs in the same way. These sorts of derived ranges are one practical example of how that can happen.

- 7 - Type Systems
  - The language supports *optional* static typing. That is, it has the ability to be dynamically typed, but static types may be declared and checked at compile time where they are desired. This is known as gradual typing[3].
- 8 - Composite Types
  - Every type is composed of a primary and a number of secondary types. Secondary types may be accessed in order using number and may also be access by name.

Consider the basic integer. It's primary value is some number, and it's secondary value is nil.

Other types have a primary type such as `list` and a secondary type containing it's items.

Examples
========

Newtonian Physics
-----------------

Calculate new positions for a list of physical object after some time step.

    update_particle ≡ pos, vel, acc, Δt →
      vel = acc × Δt
      pos = vel × Δt

Vector Magnitude
----------------

Calculates the magnitude (length) of a vector

    v ≡ 
      1,2,3

    v.mag ≡ v →
      √Σv,x → 
        x²

Fibonacci
---------

    fib ≡ n →
      { 0 if n = 0
      { 1 if n = 1
      { F(n-1) + F(n-1)
  
OOP
===

This language does not seek to provide syntactic sugar for object oriented programming. Object oriented programs can be crafted by explictly passing data structures to functions meant to operate on these structures.

Types
=====
This language is strongly and statically typed. All types are automatically inferred. This would likely be implemented using a system such as Hindley-Milner[1].

Builtins
========

Selection (filter) - σexpr(list)
Summation (reduce) - ∑(over,list)

π (pi = 3.14159…)
¬ (logical negation)

Mutability
==========

All variables are immutable once declared.

Whitespace
==========

There are two valid whitespace characters. These are space, as in 0x20, and line breaks, as in 0x12. Using tabs (0x11) or carriage returns (0x15) as whitespace characters is illegal.

References
==========

1. https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
2. https://en.wikipedia.org/wiki/Set-builder_notation
3. https://en.wikipedia.org/wiki/Gradual_typing
4. http://philip.greenspun.com/research/
5. http://www.paulgraham.com/icad.html
6. {The textbook}
7. http://www.cs.utexas.edu/~EWD/transcriptions/EWD06xx/EWD660.html
8. https://softwareengineering.stackexchange.com/questions/148790/is-the-14th-line-of-the-zen-of-python-a-reference-to-dijkstra#148794
9. https://en.wikipedia.org/wiki/Anonymous_function
10. https://en.wikipedia.org/wiki/Scope_(computer_science)#Function_scope
11. SICP
12. https://en.wikiquote.org/wiki/Programming_languages
13. Adams, Douglas. The Ultimate Hitchhiker's Guide to the Galaxy: Five Novels in One Outrageous Volume. Del Rey, 2010.
14. Brooks Jr, Frederick P. "The mythical man-month (anniversary ed.)." (1995).
15. https://en.wikiquote.org/wiki/Edsger_W._Dijkstra
16. Dijkstra, Edsger. 1972 Turing Award Lecture[1], Communications of the ACM 15 (10), October 1972: pp. 859–866.

