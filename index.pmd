% ifONLY (draft specification)
% Jon Craton

> We were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp. 
> 
> - Guy Steele, co-author of the Java spec [5] 

>  Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified bug-ridden slow implementation of half of Common Lisp.
>
> - Philip Greenspun [4]

> Programming should be regarded as the art of telling another human being what one wants the computer to do.
>
> - Don Knuth [6]

> I thought that it was a firm principle of language design --out of concern for programming as a human activity-- that in all respects equivalent programs should have few possibilities for different representations (possibility for differences ideally not going beyond the arbitrary choice of identifiers and the arbitrary ordering of syntactically unordered components). Otherwise completely different styles of programming arise unnecessarily, thereby hampering maintainability, readability and what have you. This requires from the language designers the courage to make up their minds!
>
> - Edsger Dijkstra [7][8]

Derived Ranges
--------------

Consider iterating over the even integers between 1 and 100 in JavaScript:

    for(i=2; i<=100; i+=2) {
      \\ Do something with i
    }

Or doing the same thing in Python:

    for i in range(2,100,2):
      \\ Do something with i

While a programmer gets very used to writing and reading these sorts of expressions, they are very far from how we would naturally express ideas to one another.

We might like to be able to do something like this:

    for i in [2,4,6,...,100]:
      \\ Do something with i

It's natural for us to grasp ideas by example, and a computer should be able to construct programs in the same way. These sorts of derived ranges are one practical example of how that can happen.

- 3 - Names, Scope, Binding
  - Names - Names include any non-whitespace characters and must not start with a number.
  - Functions are first-class objects. All function declarations are anonymous.
- 6 - Control Flow
  - Comparison - Comparison is always done by value.
  - Words (`and`, `or`, `not`) for boolean operations. Alternatively, their mathematical syntax can be used (∧,∨,¬).
  - There are no variable declarations. Variables are inferred to be local if they are assigned in a function.
  - There are no statements. Everything is an expression. Consider the following:

Derived Operations
------------------

The language defines no operations. They are all derived by example.

For example, a compiler would discover division from the following example:

```
derive a / b matching:
  1 / 1 is 1
  2 / 2 is 1
  2 / 1 is 2
  6 / 2 is 3  
```

Or concatenation:

```
derive a + b matching:
  abc + def is abcdef
```

Functions
---------

Function may be infix, prefix, or postfix depending on how they are defined. Here's a prefix definition:

```
func pow a b:
  val = 1

  for [0...b]:
    val *= a

  return val
```

Here's the same definition for an infix `^` operator:

```
func a ^ b
  val = 1

  for [0...b]
    val *= a

  return val
```

Functions don't simply have names, but instead have a complete signature. For example, you can define a C++ ternary operator as:

``` 
func expr ? v_true : v_false
  if expr
    v_true
  else:
    v_false
```

Data types
----------

### Literals

A litteral is a string of utf8 characters. The compiler may use this as an integer, float, string, etc depending on how it is used.

Everything is an expression
---------------------------

    result = if True:
      1
    else:
      2

`result` evaluates to 1.

  - There is not a traditional imperative looping construct. Consider the following example:

```
squares = for i in [0,1,…,4]:
  i*i

print(squares)
```

This prints "[0,1,4,9,16]". However, it does not evaluate anything until squares needs to be printed. The following code executes exactly 1 multiply operation, because squares is evaluated lazily:

```
squares = for i in [0,1,…,4]:
  i*i

print(squares[0])
```

- 7 - Type Systems
  - The language supports *optional* static typing. That is, it has the ability to be dynamically typed, but static types may be declared and checked at compile time where they are desired. This is known as gradual typing[3].
- 8 - Composite Types
  - Every type is composed of a primary and a number of secondary types. Secondary types may be accessed in order using number and may also be access by name.

Consider the basic integer. It's primary value is some number, and it's secondary value is nil.

Other types have a primary type such as `list` and a secondary type containing it's items.

Guiding Principles
==================

1. Correct code should look correct. Incorrect code should look incorrect.
  - White space is significant
  - Side effects should be loud and obvious
2. There should be exactly one correct way to perform a simple task.
  - The language has an embedded code formatter to bring code up to spec with very specific and required style guidelines.
3. Inline testing and documentation is a core construct.
4. Where existing mathematical notation exists, it should be used in place of inventing to notation.
5. Variables cannot be set to values. They may only be set to expressions.

OOP
===

This language does not seek to provide syntactic sugar for object oriented programming. Object oriented programs can be crafted by explictly passing data structures to functions meant to operate on these structures.

Types
=====
This language is strongly and statically types. All types are automatically inferred. This would likely be implemented using a system such as Hindley-Milner[1].

Literals
--------

Single values may be part of one or more of the following types:

- `boolean` (x∈{0,1})
- `real` (x∈ℝ|x=1) - e.g. 3.14159… - Any real number. This captures infinite precision.
  - `rational` (x∈ℚ) - e.g. 0.33…
  - `integer` (x∈ℤ) - e.g. -17 - Integers may be used anywhere numbers are expected. The reverse is not true. Some operations may require integer parameters, such as list indices.
    - `natural` (x∈ℕ) e.g. 4 Some operations may require `natural` parameters, such as list indices. Natural numbers include 0 for this purpose.
- `grapheme` - e.g. q - The smallest unit of a written language. This should absolutely not be confused with a byte, word, character, or any other implementation detail.

The language has no support for the following:

- Direct bit manipulation
- Strings

Lists
-----

Lists are one of the two core building blocks of the type system. A list contains a number of values (possibly infinite values), each having the same type. Lists are constructed without any special delimiters as follows:

    abcd
    1.0 2.0 3.0
    1 2 3

The following are not valid lists:

    1 abcd

Tuples
------

A tuple is an ordered grouping of values. Values can be of any type, and the length of a tuple may be infinite.

Tuples are always defined using set builder notation in final code[2]: `⟨x∈ℕ|x≤3⟩` produces `⟨1,2,3⟩`

Tuples may also be defined using the following in draft code:

- Roster notation: `⟨1,2,3⟩`
- Ellipsis notation: `⟨1,2,3,…⟩` Note the use of a unicode ellipsis. Three periods are not an ellipsis…

Roster and ellipsis notation are both permanently converted to set builder notation by the formatting pass.

The exception to this rule is that finite grapheme tuples must be built as `"abcd"`. Roster notation will be automatically converted to this syntax by the formatter.

Sets
----

Sets are simply tuples without order or duplicate values. The syntax is the same as tuples with angle brackets replaced by set brackets ({}).

Stream
------

A stream is mutable.

Examples
========

Count to 10
-----------

    λ
      ⟨x∈ℕ|x≤10⟩

Hello, {name}!
--------------

    λ in∈⟨x∈G⟩ =
      "Hello, " ∪ in ∪ "!"

Factorial
--------------

    λ in∈⟨x∈G⟩ =
      "Hello, " ∪ in ∪ "!"

Control Flow
============

This doesn't exist as it is typically conceptualized in imperative languages. There are several provided expression to handle cases of control flow that may be desired.



Scope
=====

Builtins
========

Selection (filter) - σexpr(list)
Summation (reduce) - ∑over,list

π (pi = 3.14159…)
¬ (logical negation)

Mutability
==========

All variables are immutable once declared.

Whitespace
==========

There are two valid whitespace characters. These are space, as in 0x20, and line breaks, as in 0x12. Using tabs (0x11) or carriage returns (0x15) as whitespace characters is illegal.

References
==========

1. https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
2. https://en.wikipedia.org/wiki/Set-builder_notation
3. https://en.wikipedia.org/wiki/Gradual_typing
4. http://philip.greenspun.com/research/
5. http://www.paulgraham.com/icad.html
6. {The textbook}
7. http://www.cs.utexas.edu/~EWD/transcriptions/EWD06xx/EWD660.html
8. https://softwareengineering.stackexchange.com/questions/148790/is-the-14th-line-of-the-zen-of-python-a-reference-to-dijkstra#148794
